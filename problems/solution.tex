\documentclass{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\begin{document}

\section*{A - A Simple Geometry Problem}



\section*{B - Barfoosia Tax Return}

This is an ad hoc problem. You can use if-else branch to determine the total amount of tax, and take the difference between it and the withheld tax to find out the amount refunded/owed. 

\section*{C - Common Mistake}



\section*{D - Dull Game}
We notice that, at each step, if we choose the a point with $x$-coordinate $x_0$, then the maximum
point can be obtained is $y_0$ where:
\begin{itemize}
\item
If there exists segments that cover $x_0$, $y_0$ is the minimum height of all such segments.
\item
Otherwise, $y_0 = m$.
\end{itemize}
Thus, at each step, we only need to find the value of $x_0$ that results in the largest $y_0$.\\

\noindent This problem is a basic application of segment tree with lazy propagation. We need to construct a
segment tree where each node stores the following value of some segment $[l, r] (0 \leq l \leq r \leq n)$:
The highest point can possibly attained if we choose $x_0 \in [l, r]$. The update and get methods can be
implemented with lazy propagation. You can look at the solution code for more detail.\\

At each step, updating takes $O(\log{n})$ while querying takes $O(1)$. Thus, the total complexity is $O(n\log{n})$.


\section*{E - Enclose These Cows}
Consider directed edges between all pairs of poles. We want to pick those directed edges that has all cows on its left side. Then a cycle formed by these edges is a valid enclosing fence, and the problem reduces to finding the shortest cycle in a directed graph, which can be done with Floyd in $O(N^3)$. Overall complexity is $O(M N^2 + N^3)$. 

\section*{F - Featured Animals}

Placing animals from left to right is a Markov process, so we can use matrix multiplication. Let state vector have $i$th element representing the number of configurations when the current cage contains type $i$ animal. Transition matrix is the one matrix except where corresponding adjacent types are forbidden, in which case the matrix element is zero. We must zero out some state vector elements in certain stages because these cages forbid some types of animals. Time complexity is $O(N M^2)$. 

We can optimize with fast matrix exponentiation. This will give us time complexity $O(M^3 K \log{\frac{N}{K}}) = O(M^3 K \log{N})$. We can further precompute base matrices, yielding time complexity $O(M^3 \log{N} + M^2 K \log{\frac{N}{K}}) = O((M+K) M^2 \log{N})$. 

\section*{G - Greedy String Match}



\section*{H - Hard Combinatorics}
To solve this problem, we need to know the following combinatorics problem: The number of ways to move from $(0, 0)$ to $(x, y)$ (where $x, y \in \mathbb{N}, x, y > 0$), 
allowing only moving right and up (along the axises with
step size $1$), is
\begin{equation}
\begin{pmatrix}
x + y\\
x
\end{pmatrix}
\end{equation}
Thus, for any $1 \leq i, j \leq N$,
\begin{equation}
\begin{pmatrix}
A_i + B_j + C_i + D_j\\
A_i + B_j
\end{pmatrix}
\end{equation}
Is the number of ways to move from $(-B_j, -D_j)$ to $(A_i, C_i)$ giving the above constraints.\\

\noindent Let us denote $(-B_1, -D_1), (-B_2, -D_2), \cdots, (-B_N, -D_N)$ as starting points and $(A_1, C_1), (A_2, C_2), \cdots, (A_N, C_N)$ as ending points. Then
\begin{equation}
\sum_{i = 1}^N\sum_{j = 1}^N\begin{pmatrix}
A_i + B_j + C_i + D_j\\
A_i + B_j
\end{pmatrix}
\end{equation}
is the number of ways to move from any starting point to any ending point giving the above constraints. This problem can be solved with dynamic programming. Let
$f(x, y)$ be the number of ways to move from some starting points to $(x, y)$. Then, we have the recursive formula:
\begin{equation}
f(x, y) = f(x - 1, y) + f(x, y - 1)
\end{equation}

\noindent Hence, the complexity is $O((maxA - maxB) \times (maxC - maxD))$.

\section*{I - Impossible Task}
Consider $n = p_1^{\alpha_1}p_2^{\alpha_2}\cdots p_k^{\alpha_k}$ where $p_1, p_2, \cdots, p_k$ are prime factors of $n$.
Then, the sum $S$ of all factors of $n$ can be calculated as
\begin{equation}
S = \left(1 + p_1 + \cdots + p_1^{\alpha_1}\right)\left(1 + p_2 + \cdots + p_2^{\alpha_2}\right)\cdots\left(1 + p_k + \cdots + p_k^{\alpha_k}\right)
\end{equation}
Thus, we only need to compute $p_i, \alpha_i$ for all $1 \leq i \leq k$. Since $\sum_{i = 1}^k \alpha_k \leq \ceil{\log_2{n}}$, with
all $p_i, \alpha_i$ provided, $S$ can be calculated in $O(\log{n})$.\\

\noindent To calculate all prime factors of $n$ and their power quickly, we can use Erastothene Sieve with a modification. While
running the sieve, for each composite number, we can store any of its prime number. Then, we can factorize any number $n$ in
$O(\log{n})$ (see solution code for more details).

For each $n$, we need $O(\log{n})$ time to answer the query, thus the total complexity is $O(q\log{n})$. Note: Here we excluded
the complexity of running the sieve since its complexity $O(N\log{N})$ (where $N$ is the maximum value of $n$), in this case, is
a constant.

\section*{J - Just A Hike!}
We can solve the problem using binary search on the columns. Suppose we are searching in $[l, r]$. 
Let $mid = \floor{\frac{l + r}{2}}$. Let 
\begin{equation}
\begin{split}
&h_{mid} = argmax_{1 \leq i \leq m} h[i, mid]\\
&h_l = 
\begin{cases}
argmax_{1 \leq i \leq m} h[i, mid - 1] & \text{ if $mid - 1 \geq l$}\\
-1 & \text{ otherwise}
\end{cases}\\
&h_r = 
\begin{cases}
argmax_{1 \leq i \leq m} h[i, mid + 1] & \text{ if $mid + 1 \leq r$}\\
-1 & \text{ otherwise}
\end{cases}
\end{split}
\end{equation}
\begin{itemize}
\item
If $h[1, h_{mid}]$ is a peak then return $(mid, h_{mid})$ as the result.
\item
If $h[1, h_{mid}] < h[1, h_r]$ (given that $h_r \neq -1$), there exists a peak in the segment $[mid + 1, r]$. Thus,
we apply binary search on $[mid + 1, r]$.
\item
If $h[1, h_{mid}] < h[1, h_l]$ (given that $h_l \neq -1$), there exists a peak in the segment $[l, mid - 1]$. Thus, we apply binary segment on $[l, mid - 1]$.
\end{itemize}
We starts the search with segment $[1, n]$.\\

\noindent At each step, we need to calculate all the values in $3$ columns $mid - 1, mid, mid + 1$. This can be done in $O(m)$. Thus, the total complexity is $O(m\log{n})$.

\section*{K - Kindle the Bonfire}



\section{L - Land of Fantasy}



\section{M - Macrosoft}



\end{document}
